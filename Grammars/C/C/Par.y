-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module C.Par
  ( happyError
  , myLexer
  , pProgram
  , pStm
  , pExp
  ) where

import Prelude

import qualified C.Abs
import C.Lex

}

%name pProgram Program
%name pStm Stm
%name pExp Exp
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'                           { PT _ (TS _ 1)             }
  '!='                          { PT _ (TS _ 2)             }
  '%'                           { PT _ (TS _ 3)             }
  '%='                          { PT _ (TS _ 4)             }
  '&'                           { PT _ (TS _ 5)             }
  '&&'                          { PT _ (TS _ 6)             }
  '&='                          { PT _ (TS _ 7)             }
  '('                           { PT _ (TS _ 8)             }
  ')'                           { PT _ (TS _ 9)             }
  '*'                           { PT _ (TS _ 10)            }
  '*='                          { PT _ (TS _ 11)            }
  '+'                           { PT _ (TS _ 12)            }
  '++'                          { PT _ (TS _ 13)            }
  '+='                          { PT _ (TS _ 14)            }
  ','                           { PT _ (TS _ 15)            }
  '-'                           { PT _ (TS _ 16)            }
  '--'                          { PT _ (TS _ 17)            }
  '-='                          { PT _ (TS _ 18)            }
  '->'                          { PT _ (TS _ 19)            }
  '.'                           { PT _ (TS _ 20)            }
  '...'                         { PT _ (TS _ 21)            }
  '/'                           { PT _ (TS _ 22)            }
  '/='                          { PT _ (TS _ 23)            }
  ':'                           { PT _ (TS _ 24)            }
  ';'                           { PT _ (TS _ 25)            }
  '<'                           { PT _ (TS _ 26)            }
  '<<'                          { PT _ (TS _ 27)            }
  '<<='                         { PT _ (TS _ 28)            }
  '<='                          { PT _ (TS _ 29)            }
  '='                           { PT _ (TS _ 30)            }
  '=='                          { PT _ (TS _ 31)            }
  '>'                           { PT _ (TS _ 32)            }
  '>='                          { PT _ (TS _ 33)            }
  '>>'                          { PT _ (TS _ 34)            }
  '>>='                         { PT _ (TS _ 35)            }
  '?'                           { PT _ (TS _ 36)            }
  'Context'                     { PT _ (TS _ 37)            }
  'RtemsModelEventsMgr_Context' { PT _ (TS _ 38)            }
  'Typedef_name'                { PT _ (TS _ 39)            }
  '['                           { PT _ (TS _ 40)            }
  ']'                           { PT _ (TS _ 41)            }
  '^'                           { PT _ (TS _ 42)            }
  '^='                          { PT _ (TS _ 43)            }
  'auto'                        { PT _ (TS _ 44)            }
  'break'                       { PT _ (TS _ 45)            }
  'case'                        { PT _ (TS _ 46)            }
  'char'                        { PT _ (TS _ 47)            }
  'const'                       { PT _ (TS _ 48)            }
  'continue'                    { PT _ (TS _ 49)            }
  'default'                     { PT _ (TS _ 50)            }
  'do'                          { PT _ (TS _ 51)            }
  'double'                      { PT _ (TS _ 52)            }
  'else'                        { PT _ (TS _ 53)            }
  'enum'                        { PT _ (TS _ 54)            }
  'extern'                      { PT _ (TS _ 55)            }
  'float'                       { PT _ (TS _ 56)            }
  'for'                         { PT _ (TS _ 57)            }
  'goto'                        { PT _ (TS _ 58)            }
  'if'                          { PT _ (TS _ 59)            }
  'int'                         { PT _ (TS _ 60)            }
  'long'                        { PT _ (TS _ 61)            }
  'register'                    { PT _ (TS _ 62)            }
  'return'                      { PT _ (TS _ 63)            }
  'rtems_event_set'             { PT _ (TS _ 64)            }
  'rtems_id'                    { PT _ (TS _ 65)            }
  'rtems_status_code'           { PT _ (TS _ 66)            }
  'rtems_task_argument'         { PT _ (TS _ 67)            }
  'rtems_task_priority'         { PT _ (TS _ 68)            }
  'short'                       { PT _ (TS _ 69)            }
  'signed'                      { PT _ (TS _ 70)            }
  'size_t'                      { PT _ (TS _ 71)            }
  'sizeof'                      { PT _ (TS _ 72)            }
  'static'                      { PT _ (TS _ 73)            }
  'struct'                      { PT _ (TS _ 74)            }
  'switch'                      { PT _ (TS _ 75)            }
  'typedef'                     { PT _ (TS _ 76)            }
  'union'                       { PT _ (TS _ 77)            }
  'unsigned'                    { PT _ (TS _ 78)            }
  'void'                        { PT _ (TS _ 79)            }
  'volatile'                    { PT _ (TS _ 80)            }
  'while'                       { PT _ (TS _ 81)            }
  '{'                           { PT _ (TS _ 82)            }
  '|'                           { PT _ (TS _ 83)            }
  '|='                          { PT _ (TS _ 84)            }
  '||'                          { PT _ (TS _ 85)            }
  '}'                           { PT _ (TS _ 86)            }
  '~'                           { PT _ (TS _ 87)            }
  L_charac                      { PT _ (TC $$)              }
  L_doubl                       { PT _ (TD $$)              }
  L_integ                       { PT _ (TI $$)              }
  L_quoted                      { PT _ (TL $$)              }
  L_Unsigned                    { PT _ (T_Unsigned $$)      }
  L_Long                        { PT _ (T_Long $$)          }
  L_UnsignedLong                { PT _ (T_UnsignedLong $$)  }
  L_Hexadecimal                 { PT _ (T_Hexadecimal $$)   }
  L_HexUnsigned                 { PT _ (T_HexUnsigned $$)   }
  L_HexLong                     { PT _ (T_HexLong $$)       }
  L_HexUnsLong                  { PT _ (T_HexUnsLong $$)    }
  L_Octal                       { PT _ (T_Octal $$)         }
  L_OctalUnsigned               { PT _ (T_OctalUnsigned $$) }
  L_OctalLong                   { PT _ (T_OctalLong $$)     }
  L_OctalUnsLong                { PT _ (T_OctalUnsLong $$)  }
  L_CDouble                     { PT _ (T_CDouble $$)       }
  L_CFloat                      { PT _ (T_CFloat $$)        }
  L_CLongDouble                 { PT _ (T_CLongDouble $$)   }
  L_CIdent                      { PT _ (T_CIdent $$)        }

%%

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Unsigned :: { C.Abs.Unsigned }
Unsigned  : L_Unsigned { C.Abs.Unsigned $1 }

Long :: { C.Abs.Long }
Long  : L_Long { C.Abs.Long $1 }

UnsignedLong :: { C.Abs.UnsignedLong }
UnsignedLong  : L_UnsignedLong { C.Abs.UnsignedLong $1 }

Hexadecimal :: { C.Abs.Hexadecimal }
Hexadecimal  : L_Hexadecimal { C.Abs.Hexadecimal $1 }

HexUnsigned :: { C.Abs.HexUnsigned }
HexUnsigned  : L_HexUnsigned { C.Abs.HexUnsigned $1 }

HexLong :: { C.Abs.HexLong }
HexLong  : L_HexLong { C.Abs.HexLong $1 }

HexUnsLong :: { C.Abs.HexUnsLong }
HexUnsLong  : L_HexUnsLong { C.Abs.HexUnsLong $1 }

Octal :: { C.Abs.Octal }
Octal  : L_Octal { C.Abs.Octal $1 }

OctalUnsigned :: { C.Abs.OctalUnsigned }
OctalUnsigned  : L_OctalUnsigned { C.Abs.OctalUnsigned $1 }

OctalLong :: { C.Abs.OctalLong }
OctalLong  : L_OctalLong { C.Abs.OctalLong $1 }

OctalUnsLong :: { C.Abs.OctalUnsLong }
OctalUnsLong  : L_OctalUnsLong { C.Abs.OctalUnsLong $1 }

CDouble :: { C.Abs.CDouble }
CDouble  : L_CDouble { C.Abs.CDouble $1 }

CFloat :: { C.Abs.CFloat }
CFloat  : L_CFloat { C.Abs.CFloat $1 }

CLongDouble :: { C.Abs.CLongDouble }
CLongDouble  : L_CLongDouble { C.Abs.CLongDouble $1 }

CIdent :: { C.Abs.CIdent }
CIdent  : L_CIdent { C.Abs.CIdent $1 }

Program :: { C.Abs.Program }
Program : ListExternal_declaration { C.Abs.Progr $1 }

ListExternal_declaration :: { [C.Abs.External_declaration] }
ListExternal_declaration
  : External_declaration { (:[]) $1 }
  | External_declaration ListExternal_declaration { (:) $1 $2 }

External_declaration :: { C.Abs.External_declaration }
External_declaration
  : Function_def { C.Abs.Afunc $1 } | Dec { C.Abs.Global $1 }

Function_def :: { C.Abs.Function_def }
Function_def
  : ListDeclaration_specifier Declarator ListDec Compound_stm { C.Abs.OldFunc $1 $2 $3 $4 }
  | ListDeclaration_specifier Declarator Compound_stm { C.Abs.NewFunc $1 $2 $3 }
  | Declarator ListDec Compound_stm { C.Abs.OldFuncInt $1 $2 $3 }
  | Declarator Compound_stm { C.Abs.NewFuncInt $1 $2 }

Dec :: { C.Abs.Dec }
Dec
  : ListDeclaration_specifier ';' { C.Abs.NoDeclarator $1 }
  | ListDeclaration_specifier ListInit_declarator ';' { C.Abs.Declarators $1 $2 }

ListDec :: { [C.Abs.Dec] }
ListDec : Dec { (:[]) $1 } | Dec ListDec { (:) $1 $2 }

ListDeclaration_specifier :: { [C.Abs.Declaration_specifier] }
ListDeclaration_specifier
  : Declaration_specifier { (:[]) $1 }
  | Declaration_specifier ListDeclaration_specifier { (:) $1 $2 }

Declaration_specifier :: { C.Abs.Declaration_specifier }
Declaration_specifier
  : Type_specifier { C.Abs.Type $1 }
  | Storage_class_specifier { C.Abs.Storage $1 }
  | Type_qualifier { C.Abs.SpecProp $1 }

ListInit_declarator :: { [C.Abs.Init_declarator] }
ListInit_declarator
  : Init_declarator { (:[]) $1 }
  | Init_declarator ',' ListInit_declarator { (:) $1 $3 }

Init_declarator :: { C.Abs.Init_declarator }
Init_declarator
  : Declarator { C.Abs.OnlyDecl $1 }
  | Declarator '=' Initializer { C.Abs.InitDecl $1 $3 }

Type_specifier :: { C.Abs.Type_specifier }
Type_specifier
  : 'void' { C.Abs.Tvoid }
  | 'char' { C.Abs.Tchar }
  | 'short' { C.Abs.Tshort }
  | 'int' { C.Abs.Tint }
  | 'long' { C.Abs.Tlong }
  | 'float' { C.Abs.Tfloat }
  | 'double' { C.Abs.Tdouble }
  | 'signed' { C.Abs.Tsigned }
  | 'unsigned' { C.Abs.Tunsigned }
  | Struct_or_union_spec { C.Abs.Tstruct $1 }
  | Enum_specifier { C.Abs.Tenum $1 }
  | 'Typedef_name' { C.Abs.Tname }
  | 'rtems_status_code' { C.Abs.Trtsc }
  | 'rtems_event_set' { C.Abs.Trtes }
  | 'rtems_id' { C.Abs.Trtid }
  | 'Context' { C.Abs.Trtctx }
  | 'rtems_task_priority' { C.Abs.Trttp }
  | 'size_t' { C.Abs.Tszet }
  | 'RtemsModelEventsMgr_Context' { C.Abs.Tevctx }
  | 'rtems_task_argument' { C.Abs.Trtta }

Storage_class_specifier :: { C.Abs.Storage_class_specifier }
Storage_class_specifier
  : 'typedef' { C.Abs.MyType }
  | 'extern' { C.Abs.GlobalPrograms }
  | 'static' { C.Abs.LocalProgram }
  | 'auto' { C.Abs.LocalBlock }
  | 'register' { C.Abs.LocalReg }

Type_qualifier :: { C.Abs.Type_qualifier }
Type_qualifier
  : 'const' { C.Abs.Const } | 'volatile' { C.Abs.NoOptim }

Struct_or_union_spec :: { C.Abs.Struct_or_union_spec }
Struct_or_union_spec
  : Struct_or_union CIdent '{' ListStruct_dec '}' { C.Abs.Tag $1 $2 $4 }
  | Struct_or_union '{' ListStruct_dec '}' { C.Abs.Unique $1 $3 }
  | Struct_or_union CIdent { C.Abs.TagType $1 $2 }

Struct_or_union :: { C.Abs.Struct_or_union }
Struct_or_union
  : 'struct' { C.Abs.Struct } | 'union' { C.Abs.Union }

ListStruct_dec :: { [C.Abs.Struct_dec] }
ListStruct_dec
  : Struct_dec { (:[]) $1 } | Struct_dec ListStruct_dec { (:) $1 $2 }

Struct_dec :: { C.Abs.Struct_dec }
Struct_dec
  : ListSpec_qual ListStruct_declarator ';' { C.Abs.Structen $1 $2 }

ListSpec_qual :: { [C.Abs.Spec_qual] }
ListSpec_qual
  : Spec_qual { (:[]) $1 } | Spec_qual ListSpec_qual { (:) $1 $2 }

Spec_qual :: { C.Abs.Spec_qual }
Spec_qual
  : Type_specifier { C.Abs.TypeSpec $1 }
  | Type_qualifier { C.Abs.QualSpec $1 }

ListStruct_declarator :: { [C.Abs.Struct_declarator] }
ListStruct_declarator
  : Struct_declarator { (:[]) $1 }
  | Struct_declarator ',' ListStruct_declarator { (:) $1 $3 }

Struct_declarator :: { C.Abs.Struct_declarator }
Struct_declarator
  : Declarator { C.Abs.Decl $1 }
  | ':' Constant_expression { C.Abs.Field $2 }
  | Declarator ':' Constant_expression { C.Abs.DecField $1 $3 }

Enum_specifier :: { C.Abs.Enum_specifier }
Enum_specifier
  : 'enum' '{' ListEnumerator '}' { C.Abs.EnumDec $3 }
  | 'enum' CIdent '{' ListEnumerator '}' { C.Abs.EnumName $2 $4 }
  | 'enum' CIdent { C.Abs.EnumVar $2 }

ListEnumerator :: { [C.Abs.Enumerator] }
ListEnumerator
  : Enumerator { (:[]) $1 }
  | Enumerator ',' ListEnumerator { (:) $1 $3 }

Enumerator :: { C.Abs.Enumerator }
Enumerator
  : CIdent { C.Abs.Plain $1 }
  | CIdent '=' Constant_expression { C.Abs.EnumInit $1 $3 }

Declarator :: { C.Abs.Declarator }
Declarator
  : Pointer Direct_declarator { C.Abs.BeginPointer $1 $2 }
  | Direct_declarator { C.Abs.NoPointer $1 }

Direct_declarator :: { C.Abs.Direct_declarator }
Direct_declarator
  : CIdent { C.Abs.Name $1 }
  | '(' Declarator ')' { C.Abs.ParenDecl $2 }
  | Direct_declarator '[' Constant_expression ']' { C.Abs.InnitArray $1 $3 }
  | Direct_declarator '[' ']' { C.Abs.Incomplete $1 }
  | Direct_declarator '(' Parameter_type ')' { C.Abs.NewFuncDec $1 $3 }
  | Direct_declarator '(' ListCIdent ')' { C.Abs.OldFuncDef $1 $3 }
  | Direct_declarator '(' ')' { C.Abs.OldFuncDec $1 }

Pointer :: { C.Abs.Pointer }
Pointer
  : '*' { C.Abs.Point }
  | '*' ListType_qualifier { C.Abs.PointQual $2 }
  | '*' Pointer { C.Abs.PointPoint $2 }
  | '*' ListType_qualifier Pointer { C.Abs.PointQualPoint $2 $3 }

ListType_qualifier :: { [C.Abs.Type_qualifier] }
ListType_qualifier
  : Type_qualifier { (:[]) $1 }
  | Type_qualifier ListType_qualifier { (:) $1 $2 }

Parameter_type :: { C.Abs.Parameter_type }
Parameter_type
  : Parameter_declarations { C.Abs.AllSpec $1 }
  | Parameter_declarations ',' '...' { C.Abs.More $1 }

Parameter_declarations :: { C.Abs.Parameter_declarations }
Parameter_declarations
  : Parameter_declaration { C.Abs.ParamDec $1 }
  | Parameter_declarations ',' Parameter_declaration { C.Abs.MoreParamDec $1 $3 }

Parameter_declaration :: { C.Abs.Parameter_declaration }
Parameter_declaration
  : ListDeclaration_specifier { C.Abs.OnlyType $1 }
  | ListDeclaration_specifier Declarator { C.Abs.TypeAndParam $1 $2 }
  | ListDeclaration_specifier Abstract_declarator { C.Abs.Abstract $1 $2 }

ListCIdent :: { [C.Abs.CIdent] }
ListCIdent
  : CIdent { (:[]) $1 } | CIdent ',' ListCIdent { (:) $1 $3 }

Initializer :: { C.Abs.Initializer }
Initializer
  : Exp2 { C.Abs.InitExpr $1 }
  | '{' Initializers '}' { C.Abs.InitListOne $2 }
  | '{' Initializers ',' '}' { C.Abs.InitListTwo $2 }

Initializers :: { C.Abs.Initializers }
Initializers
  : Initializer { C.Abs.AnInit $1 }
  | Initializers ',' Initializer { C.Abs.MoreInit $1 $3 }

Type_name :: { C.Abs.Type_name }
Type_name
  : ListSpec_qual { C.Abs.PlainType $1 }
  | ListSpec_qual Abstract_declarator { C.Abs.ExtendedType $1 $2 }

Abstract_declarator :: { C.Abs.Abstract_declarator }
Abstract_declarator
  : Pointer { C.Abs.PointerStart $1 }
  | Dir_abs_dec { C.Abs.Advanced $1 }
  | Pointer Dir_abs_dec { C.Abs.PointAdvanced $1 $2 }

Dir_abs_dec :: { C.Abs.Dir_abs_dec }
Dir_abs_dec
  : '(' Abstract_declarator ')' { C.Abs.WithinParentes $2 }
  | '[' ']' { C.Abs.Array }
  | '[' Constant_expression ']' { C.Abs.InitiatedArray $2 }
  | Dir_abs_dec '[' ']' { C.Abs.UnInitiated $1 }
  | Dir_abs_dec '[' Constant_expression ']' { C.Abs.Initiated $1 $3 }
  | '(' ')' { C.Abs.OldFunction }
  | '(' Parameter_type ')' { C.Abs.NewFunction $2 }
  | Dir_abs_dec '(' ')' { C.Abs.OldFuncExpr $1 }
  | Dir_abs_dec '(' Parameter_type ')' { C.Abs.NewFuncExpr $1 $3 }

Stm :: { C.Abs.Stm }
Stm
  : Labeled_stm { C.Abs.LabelS $1 }
  | Compound_stm { C.Abs.CompS $1 }
  | Expression_stm { C.Abs.ExprS $1 }
  | Selection_stm { C.Abs.SelS $1 }
  | Iter_stm { C.Abs.IterS $1 }
  | Jump_stm { C.Abs.JumpS $1 }

Labeled_stm :: { C.Abs.Labeled_stm }
Labeled_stm
  : CIdent ':' Stm { C.Abs.SlabelOne $1 $3 }
  | 'case' Constant_expression ':' Stm { C.Abs.SlabelTwo $2 $4 }
  | 'default' ':' Stm { C.Abs.SlabelThree $3 }

Compound_stm :: { C.Abs.Compound_stm }
Compound_stm
  : '{' '}' { C.Abs.ScompOne }
  | '{' ListStm '}' { C.Abs.ScompTwo $2 }
  | '{' ListDec '}' { C.Abs.ScompThree $2 }
  | '{' ListDec ListStm '}' { C.Abs.ScompFour $2 $3 }

Expression_stm :: { C.Abs.Expression_stm }
Expression_stm
  : ';' { C.Abs.SexprOne } | Exp ';' { C.Abs.SexprTwo $1 }

Selection_stm :: { C.Abs.Selection_stm }
Selection_stm
  : 'if' '(' Exp ')' Stm { C.Abs.SselOne $3 $5 }
  | 'if' '(' Exp ')' Stm 'else' Stm { C.Abs.SselTwo $3 $5 $7 }
  | 'switch' '(' Exp ')' Stm { C.Abs.SselThree $3 $5 }

Iter_stm :: { C.Abs.Iter_stm }
Iter_stm
  : 'while' '(' Exp ')' Stm { C.Abs.SiterOne $3 $5 }
  | 'do' Stm 'while' '(' Exp ')' ';' { C.Abs.SiterTwo $2 $5 }
  | 'for' '(' Expression_stm Expression_stm ')' Stm { C.Abs.SiterThree $3 $4 $6 }
  | 'for' '(' Expression_stm Expression_stm Exp ')' Stm { C.Abs.SiterFour $3 $4 $5 $7 }

Jump_stm :: { C.Abs.Jump_stm }
Jump_stm
  : 'goto' CIdent ';' { C.Abs.SjumpOne $2 }
  | 'continue' ';' { C.Abs.SjumpTwo }
  | 'break' ';' { C.Abs.SjumpThree }
  | 'return' ';' { C.Abs.SjumpFour }
  | 'return' Exp ';' { C.Abs.SjumpFive $2 }

ListStm :: { [C.Abs.Stm] }
ListStm : Stm { (:[]) $1 } | Stm ListStm { (:) $1 $2 }

Exp :: { C.Abs.Exp }
Exp : Exp ',' Exp2 { C.Abs.Ecomma $1 $3 } | Exp2 { $1 }

Exp2 :: { C.Abs.Exp }
Exp2
  : Exp15 Assignment_op Exp2 { C.Abs.Eassign $1 $2 $3 } | Exp3 { $1 }

Exp3 :: { C.Abs.Exp }
Exp3
  : Exp4 '?' Exp ':' Exp3 { C.Abs.Econdition $1 $3 $5 } | Exp4 { $1 }

Exp4 :: { C.Abs.Exp }
Exp4 : Exp4 '||' Exp5 { C.Abs.Elor $1 $3 } | Exp5 { $1 }

Exp5 :: { C.Abs.Exp }
Exp5 : Exp5 '&&' Exp6 { C.Abs.Eland $1 $3 } | Exp6 { $1 }

Exp6 :: { C.Abs.Exp }
Exp6 : Exp6 '|' Exp7 { C.Abs.Ebitor $1 $3 } | Exp7 { $1 }

Exp7 :: { C.Abs.Exp }
Exp7 : Exp7 '^' Exp8 { C.Abs.Ebitexor $1 $3 } | Exp8 { $1 }

Exp8 :: { C.Abs.Exp }
Exp8 : Exp8 '&' Exp9 { C.Abs.Ebitand $1 $3 } | Exp9 { $1 }

Exp9 :: { C.Abs.Exp }
Exp9
  : Exp9 '==' Exp10 { C.Abs.Eeq $1 $3 }
  | Exp9 '!=' Exp10 { C.Abs.Eneq $1 $3 }
  | Exp10 { $1 }

Exp10 :: { C.Abs.Exp }
Exp10
  : Exp10 '<' Exp11 { C.Abs.Elthen $1 $3 }
  | Exp10 '>' Exp11 { C.Abs.Egrthen $1 $3 }
  | Exp10 '<=' Exp11 { C.Abs.Ele $1 $3 }
  | Exp10 '>=' Exp11 { C.Abs.Ege $1 $3 }
  | Exp11 { $1 }

Exp11 :: { C.Abs.Exp }
Exp11
  : Exp11 '<<' Exp12 { C.Abs.Eleft $1 $3 }
  | Exp11 '>>' Exp12 { C.Abs.Eright $1 $3 }
  | Exp12 { $1 }

Exp12 :: { C.Abs.Exp }
Exp12
  : Exp12 '+' Exp13 { C.Abs.Eplus $1 $3 }
  | Exp12 '-' Exp13 { C.Abs.Eminus $1 $3 }
  | Exp13 { $1 }

Exp13 :: { C.Abs.Exp }
Exp13
  : Exp13 '*' Exp14 { C.Abs.Etimes $1 $3 }
  | Exp13 '/' Exp14 { C.Abs.Ediv $1 $3 }
  | Exp13 '%' Exp14 { C.Abs.Emod $1 $3 }
  | Exp14 { $1 }

Exp14 :: { C.Abs.Exp }
Exp14
  : '(' Type_name ')' Exp14 { C.Abs.Etypeconv $2 $4 } | Exp15 { $1 }

Exp15 :: { C.Abs.Exp }
Exp15
  : '++' Exp15 { C.Abs.Epreinc $2 }
  | '--' Exp15 { C.Abs.Epredec $2 }
  | Unary_operator Exp14 { C.Abs.Epreop $1 $2 }
  | 'sizeof' Exp15 { C.Abs.Ebytesexpr $2 }
  | 'sizeof' '(' Type_name ')' { C.Abs.Ebytestype $3 }
  | Exp16 { $1 }

Exp16 :: { C.Abs.Exp }
Exp16
  : Exp16 '[' Exp ']' { C.Abs.Earray $1 $3 }
  | Exp16 '(' ')' { C.Abs.Efunk $1 }
  | Exp16 '(' ListExp2 ')' { C.Abs.Efunkpar $1 $3 }
  | Exp16 '.' CIdent { C.Abs.Eselect $1 $3 }
  | Exp16 '->' CIdent { C.Abs.Epoint $1 $3 }
  | Exp16 '++' { C.Abs.Epostinc $1 }
  | Exp16 '--' { C.Abs.Epostdec $1 }
  | Exp17 { $1 }

Exp17 :: { C.Abs.Exp }
Exp17
  : CIdent { C.Abs.Evar $1 }
  | Constant { C.Abs.Econst $1 }
  | String { C.Abs.Estring $1 }
  | '(' Exp ')' { $2 }

Constant :: { C.Abs.Constant }
Constant
  : Double { C.Abs.Efloat $1 }
  | Char { C.Abs.Echar $1 }
  | Unsigned { C.Abs.Eunsigned $1 }
  | Long { C.Abs.Elong $1 }
  | UnsignedLong { C.Abs.Eunsignlong $1 }
  | Hexadecimal { C.Abs.Ehexadec $1 }
  | HexUnsigned { C.Abs.Ehexaunsign $1 }
  | HexLong { C.Abs.Ehexalong $1 }
  | HexUnsLong { C.Abs.Ehexaunslong $1 }
  | Octal { C.Abs.Eoctal $1 }
  | OctalUnsigned { C.Abs.Eoctalunsign $1 }
  | OctalLong { C.Abs.Eoctallong $1 }
  | OctalUnsLong { C.Abs.Eoctalunslong $1 }
  | CDouble { C.Abs.Ecdouble $1 }
  | CFloat { C.Abs.Ecfloat $1 }
  | CLongDouble { C.Abs.Eclongdouble $1 }
  | Integer { C.Abs.Eint $1 }

Constant_expression :: { C.Abs.Constant_expression }
Constant_expression : Exp3 { C.Abs.Especial $1 }

Unary_operator :: { C.Abs.Unary_operator }
Unary_operator
  : '&' { C.Abs.Address }
  | '*' { C.Abs.Indirection }
  | '+' { C.Abs.Plus }
  | '-' { C.Abs.Negative }
  | '~' { C.Abs.Complement }
  | '!' { C.Abs.Logicalneg }

ListExp2 :: { [C.Abs.Exp] }
ListExp2 : Exp2 { (:[]) $1 } | Exp2 ',' ListExp2 { (:) $1 $3 }

Assignment_op :: { C.Abs.Assignment_op }
Assignment_op
  : '=' { C.Abs.Assign }
  | '*=' { C.Abs.AssignMul }
  | '/=' { C.Abs.AssignDiv }
  | '%=' { C.Abs.AssignMod }
  | '+=' { C.Abs.AssignAdd }
  | '-=' { C.Abs.AssignSub }
  | '<<=' { C.Abs.AssignLeft }
  | '>>=' { C.Abs.AssignRight }
  | '&=' { C.Abs.AssignAnd }
  | '^=' { C.Abs.AssignXor }
  | '|=' { C.Abs.AssignOr }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

