-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Obs.Par
  ( happyError
  , myLexer
  , pListObs
  , pName
  , pArgs
  , pLMsg
  , pTaskname
  , pVarname
  , pVarval
  , pTypename
  , pState
  , pVarindex
  , pObs
  , pScalar
  , pEnd
  ) where

import Prelude

import qualified Obs.Abs
import Obs.Lex

}

%name pListObs ListObs
%name pName Name
%name pArgs Args
%name pLMsg LMsg
%name pTaskname Taskname
%name pVarname Varname
%name pVarval Varval
%name pTypename Typename
%name pState State
%name pVarindex Varindex
%name pObs Obs
%name pScalar Scalar
%name pEnd End
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '0'         { PT _ (TS _ 1)         }
  '@@@'       { PT _ (TS _ 2)         }
  'CALL'      { PT _ (TS _ 3)         }
  'DCLARRAY'  { PT _ (TS _ 4)         }
  'DECL'      { PT _ (TS _ 5)         }
  'DEF'       { PT _ (TS _ 6)         }
  'END'       { PT _ (TS _ 7)         }
  'INIT'      { PT _ (TS _ 8)         }
  'LOG'       { PT _ (TS _ 9)         }
  'NAME'      { PT _ (TS _ 10)        }
  'PTR'       { PT _ (TS _ 11)        }
  'SCALAR'    { PT _ (TS _ 12)        }
  'SEQ'       { PT _ (TS _ 13)        }
  'SIGNAL'    { PT _ (TS _ 14)        }
  'STATE'     { PT _ (TS _ 15)        }
  'STRUCT'    { PT _ (TS _ 16)        }
  'TASK'      { PT _ (TS _ 17)        }
  '_'         { PT _ (TS _ 18)        }
  L_integ     { PT _ (TI $$)          }
  L_ObsString { PT _ (T_ObsString $$) }
  L_Int       { PT _ (T_Int $$)       }
  L_TInt      { PT _ (T_TInt $$)      }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

ObsString :: { Obs.Abs.ObsString }
ObsString  : L_ObsString { Obs.Abs.ObsString $1 }

Int :: { Obs.Abs.Int }
Int  : L_Int { Obs.Abs.Int $1 }

TInt :: { Obs.Abs.TInt }
TInt  : L_TInt { Obs.Abs.TInt $1 }

ListObs :: { [Obs.Abs.Obs] }
ListObs : {- empty -} { [] } | Obs ListObs { (:) $1 $2 }

Name :: { Obs.Abs.Name }
Name : ObsString { Obs.Abs.Mname $1 }

Args :: { Obs.Abs.Args }
Args
  : ObsString { Obs.Abs.ArgsOne $1 }
  | ObsString Args { Obs.Abs.ArgsCons $1 $2 }

LMsg :: { Obs.Abs.LMsg }
LMsg
  : ObsString { Obs.Abs.LmsgOne $1 }
  | ObsString LMsg { Obs.Abs.LmsgCons $1 $2 }

Taskname :: { Obs.Abs.Taskname }
Taskname : ObsString { Obs.Abs.TaskName $1 }

Varname :: { Obs.Abs.Varname }
Varname : ObsString { Obs.Abs.VarName $1 }

Varval :: { Obs.Abs.Varval }
Varval : ObsString { Obs.Abs.VarVal $1 }

Typename :: { Obs.Abs.Typename }
Typename : ObsString { Obs.Abs.TypeName $1 }

State :: { Obs.Abs.State }
State : ObsString { Obs.Abs.State $1 }

Varindex :: { Obs.Abs.Varindex }
Varindex : Integer { Obs.Abs.VarIndex $1 }

Obs :: { Obs.Abs.Obs }
Obs
  : '@@@' '0' 'NAME' Name { Obs.Abs.ObsName $4 }
  | '@@@' Int 'LOG' LMsg { Obs.Abs.ObsLog $2 $4 }
  | '@@@' Int 'INIT' { Obs.Abs.ObsInit $2 }
  | '@@@' Int 'TASK' Taskname { Obs.Abs.ObsTask $2 $4 }
  | '@@@' Int 'SIGNAL' Integer { Obs.Abs.ObsSignal $2 $4 }
  | '@@@' Int 'DEF' Varname Varval { Obs.Abs.ObsDef $2 $4 $5 }
  | '@@@' Int 'DECL' Typename Varname Varval { Obs.Abs.ObsDeclVal $2 $4 $5 $6 }
  | '@@@' Int 'DECL' Typename Varname { Obs.Abs.ObsDecl $2 $4 $5 }
  | '@@@' Int 'DCLARRAY' Typename Varname Varval { Obs.Abs.ObsDeclArr $2 $4 $5 $6 }
  | '@@@' Int 'CALL' Args { Obs.Abs.ObsCall $2 $4 }
  | '@@@' Int 'STATE' Integer State { Obs.Abs.ObsState $2 $4 $5 }
  | '@@@' Int 'STRUCT' Varname { Obs.Abs.ObsStruct $2 $4 }
  | '@@@' Int 'SEQ' Varname Scalar { Obs.Abs.ObsSeq $2 $4 $5 }
  | '@@@' Int 'PTR' Varname Varval { Obs.Abs.ObsPtr $2 $4 $5 }
  | '@@@' Int 'SCALAR' Varname Varval { Obs.Abs.ObsScalar $2 $4 $5 }
  | '@@@' Int 'SCALAR' Varname Varindex Varval { Obs.Abs.ObsScalarIndex $2 $4 $5 $6 }
  | '@@@' Int 'END' Varname { Obs.Abs.ObsEnd $2 $4 }

Scalar :: { Obs.Abs.Scalar }
Scalar
  : '@@@' Integer '_' Varval Scalar { Obs.Abs.ObsScalarCons $2 $4 $5 }
  | End { Obs.Abs.ObsScalarNone $1 }

End :: { Obs.Abs.End }
End : '@@@' Integer 'END' Varname { Obs.Abs.ObsEndSeq $2 $4 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

